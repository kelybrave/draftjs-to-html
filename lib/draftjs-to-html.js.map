{"version":3,"sources":["webpack:///draftjs-to-html.js","webpack:///webpack/bootstrap db8e10e748f77b20def0","webpack:///./js/block.js","webpack:///./js/common.js","webpack:///./js/index.js","webpack:///./js/list.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","getBlockTag","type","blockTypesMapping","getBlockStyle","data","styles","_common","forEach","key","value","getEntitySections","entityRanges","blockLength","sections","lastOffset","r","offset","push","start","end","length","entityKey","isAtomicEntityBlock","block","isEmptyString","text","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","range","i","style","startsWith","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","map","ch","join","addStylePropertyMarkup","styleSection","styleString","getEntityMarkup","entityMap","entity","url","title","src","alignment","height","width","getInlineStyleSections","styleSections","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","getInlineStyleSectionMarkup","stylePropertySections","styleSectionText","stylePropertySection","getEntitySectionMarkup","entitySection","entitySectionMarkup","inlineStyleSections","undefined","getBlockInnerMarkup","blockMarkup","entitySections","getBlockMarkup","directional","blockHtml","blockTag","blockStyle","Object","defineProperty","unstyled","header-one","header-two","header-three","header-four","header-five","header-six","unordered-list-item","ordered-list-item","blockquote","obj","callback","hasOwnProperty","str","trim","draftToHtml","editorContent","html","blocks","listBlocks","_list","isList","listHtml","getListMarkup","_block","default","blockType","nestedListBlock","previousBlock","nestedBlock","depth"],"mappings":"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","file":"draftjs-to-html.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getBlockTag = getBlockTag;\n\texports.getBlockStyle = getBlockStyle;\n\texports.getStylesAtOffset = getStylesAtOffset;\n\texports.sameStyleAsPrevious = sameStyleAsPrevious;\n\texports.addInlineStyleMarkup = addInlineStyleMarkup;\n\texports.addStylePropertyMarkup = addStylePropertyMarkup;\n\texports.trimLeadingZeros = trimLeadingZeros;\n\texports.trimTrailingZeros = trimTrailingZeros;\n\texports.getBlockInnerMarkup = getBlockInnerMarkup;\n\texports.getBlockMarkup = getBlockMarkup;\n\t\n\tvar _common = __webpack_require__(2);\n\t\n\t/**\n\t* Mapping block-type to corresponding html tag.\n\t*/\n\tvar blockTypesMapping = {\n\t  unstyled: 'p',\n\t  'header-one': 'h1',\n\t  'header-two': 'h2',\n\t  'header-three': 'h3',\n\t  'header-four': 'h4',\n\t  'header-five': 'h5',\n\t  'header-six': 'h6',\n\t  'unordered-list-item': 'ul',\n\t  'ordered-list-item': 'ol',\n\t  blockquote: 'blockquote'\n\t};\n\t\n\t/**\n\t* Function will return HTML tag for a block.\n\t*/\n\tfunction getBlockTag(type) {\n\t  return type && blockTypesMapping[type];\n\t}\n\t\n\t/**\n\t* Function will return style string for a block.\n\t*/\n\tfunction getBlockStyle(data) {\n\t  var styles = '';\n\t  (0, _common.forEach)(data, function (key, value) {\n\t    if (value) {\n\t      styles += key + ':' + value + ';';\n\t    }\n\t  });\n\t  return styles;\n\t}\n\t\n\t/**\n\t* The function returns an array of entity-sections in blocks.\n\t* These will be areas in block which have same entity or no entity applicable to them.\n\t*/\n\tfunction getEntitySections(entityRanges, blockLength) {\n\t  var sections = [];\n\t  var lastOffset = 0;\n\t  entityRanges.forEach(function (r) {\n\t    if (r.offset > lastOffset) {\n\t      sections.push({\n\t        start: lastOffset,\n\t        end: r.offset\n\t      });\n\t    }\n\t    sections.push({\n\t      start: r.offset,\n\t      end: r.offset + r.length,\n\t      entityKey: r.key\n\t    });\n\t    lastOffset = r.offset + r.length;\n\t  });\n\t  if (lastOffset < blockLength) {\n\t    sections.push({\n\t      start: lastOffset,\n\t      end: blockLength\n\t    });\n\t  }\n\t  return sections;\n\t}\n\t\n\t/**\n\t* Function to check if the block is an atomic entity block.\n\t*/\n\tfunction isAtomicEntityBlock(block) {\n\t  if (block.entityRanges.length > 0 && (0, _common.isEmptyString)(block.text)) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t* The function will return array of inline styles applicable to the block.\n\t*/\n\tfunction getStyleArrayForBlock(block) {\n\t  var text = block.text,\n\t      inlineStyleRanges = block.inlineStyleRanges;\n\t\n\t  var inlineStyles = {\n\t    BOLD: new Array(text.length),\n\t    ITALIC: new Array(text.length),\n\t    UNDERLINE: new Array(text.length),\n\t    STRIKETHROUGH: new Array(text.length),\n\t    CODE: new Array(text.length),\n\t    SUPERSCRIPT: new Array(text.length),\n\t    SUBSCRIPT: new Array(text.length),\n\t    COLOR: new Array(text.length),\n\t    BGCOLOR: new Array(text.length),\n\t    FONTSIZE: new Array(text.length),\n\t    FONTFAMILY: new Array(text.length),\n\t    length: text.length\n\t  };\n\t  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n\t    inlineStyleRanges.forEach(function (range) {\n\t      var offset = range.offset;\n\t      var length = offset + range.length;\n\t      for (var i = offset; i < length; i += 1) {\n\t        if (range.style.startsWith('color-')) {\n\t          inlineStyles.COLOR[i] = range.style.substring(6);\n\t        } else if (range.style.startsWith('bgcolor-')) {\n\t          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n\t        } else if (range.style.startsWith('fontsize-')) {\n\t          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n\t        } else if (range.style.startsWith('fontfamily-')) {\n\t          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n\t        } else if (inlineStyles[range.style]) {\n\t          inlineStyles[range.style][i] = true;\n\t        }\n\t      }\n\t    });\n\t  }\n\t  return inlineStyles;\n\t}\n\t\n\t/**\n\t* The function will return inline style applicable at some offset within a block.\n\t*/\n\tfunction getStylesAtOffset(inlineStyles, offset) {\n\t  var styles = {};\n\t  if (inlineStyles.COLOR[offset]) {\n\t    styles.COLOR = inlineStyles.COLOR[offset];\n\t  }\n\t  if (inlineStyles.BGCOLOR[offset]) {\n\t    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n\t  }\n\t  if (inlineStyles.FONTSIZE[offset]) {\n\t    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n\t  }\n\t  if (inlineStyles.FONTFAMILY[offset]) {\n\t    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n\t  }\n\t  if (inlineStyles.UNDERLINE[offset]) {\n\t    styles.UNDERLINE = true;\n\t  }\n\t  if (inlineStyles.ITALIC[offset]) {\n\t    styles.ITALIC = true;\n\t  }\n\t  if (inlineStyles.BOLD[offset]) {\n\t    styles.BOLD = true;\n\t  }\n\t  if (inlineStyles.STRIKETHROUGH[offset]) {\n\t    styles.STRIKETHROUGH = true;\n\t  }\n\t  if (inlineStyles.CODE[offset]) {\n\t    styles.CODE = true;\n\t  }\n\t  if (inlineStyles.SUBSCRIPT[offset]) {\n\t    styles.SUBSCRIPT = true;\n\t  }\n\t  if (inlineStyles.SUPERSCRIPT[offset]) {\n\t    styles.SUPERSCRIPT = true;\n\t  }\n\t  return styles;\n\t}\n\t\n\t/**\n\t* Function returns true for a set of styles if the value of these styles at an offset\n\t* are same as that on the previous offset.\n\t*/\n\tfunction sameStyleAsPrevious(inlineStyles, styles, index) {\n\t  var sameStyled = true;\n\t  if (index > 0 && index < inlineStyles.length) {\n\t    styles.forEach(function (style) {\n\t      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n\t    });\n\t  } else {\n\t    sameStyled = false;\n\t  }\n\t  return sameStyled;\n\t}\n\t\n\t/**\n\t* Function returns html for text depending on inline style tags applicable to it.\n\t*/\n\tfunction addInlineStyleMarkup(style, content) {\n\t  if (style === 'BOLD') {\n\t    return '<strong>' + content + '</strong>';\n\t  } else if (style === 'ITALIC') {\n\t    return '<em>' + content + '</em>';\n\t  } else if (style === 'UNDERLINE') {\n\t    return '<ins>' + content + '</ins>';\n\t  } else if (style === 'STRIKETHROUGH') {\n\t    return '<del>' + content + '</del>';\n\t  } else if (style === 'CODE') {\n\t    return '<code>' + content + '</code>';\n\t  } else if (style === 'SUPERSCRIPT') {\n\t    return '<sup>' + content + '</sup>';\n\t  } else if (style === 'SUBSCRIPT') {\n\t    return '<sub>' + content + '</sub>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* The function returns text for given section of block after doing required character replacements.\n\t*/\n\tfunction getSectionText(text) {\n\t  if (text && text.length > 0) {\n\t    var chars = text.map(function (ch) {\n\t      switch (ch) {\n\t        case '\\n':\n\t          return '<br>\\n';\n\t        case '&':\n\t          return '&amp;';\n\t        case '<':\n\t          return '&lt;';\n\t        case '>':\n\t          return '&gt;';\n\t        default:\n\t          return ch;\n\t      }\n\t    });\n\t    return chars.join('');\n\t  }\n\t  return '';\n\t}\n\t\n\t/**\n\t* Function returns html for text depending on inline style tags applicable to it.\n\t*/\n\tfunction addStylePropertyMarkup(styleSection) {\n\t  var styles = styleSection.styles,\n\t      text = styleSection.text;\n\t\n\t  var content = getSectionText(text);\n\t  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n\t    var styleString = 'style=\"';\n\t    if (styles.COLOR) {\n\t      styleString += 'color: ' + styles.COLOR + ';';\n\t    }\n\t    if (styles.BGCOLOR) {\n\t      styleString += 'background-color: ' + styles.BGCOLOR + ';';\n\t    }\n\t    if (styles.FONTSIZE) {\n\t      styleString += 'font-size: ' + styles.FONTSIZE + 'px;';\n\t    }\n\t    if (styles.FONTFAMILY) {\n\t      styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n\t    }\n\t    styleString += '\"';\n\t    return '<span ' + styleString + '>' + content + '</span>';\n\t  }\n\t  return content;\n\t}\n\t\n\t/**\n\t* Function will return markup for Entity.\n\t*/\n\tfunction getEntityMarkup(entityMap, entityKey, text) {\n\t  var entity = entityMap[entityKey];\n\t  if (entity.type === 'MENTION') {\n\t    return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n\t  }\n\t  if (entity.type === 'LINK') {\n\t    return '<a href=\"' + entity.data.url + '\">' + entity.data.title + '</a>';\n\t  }\n\t  if (entity.type === 'IMAGE') {\n\t    return '<img src=\"' + entity.data.src + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n\t  }\n\t  if (entity.type === 'EMBEDDED_LINK') {\n\t    return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\" allowFullScreen />';\n\t  }\n\t  return text;\n\t}\n\t\n\t/**\n\t* For a given section in a block the function will return a further list of sections,\n\t* with similar inline styles applicable to them.\n\t*/\n\tfunction getInlineStyleSections(block, styles, start, end) {\n\t  var styleSections = [];\n\t  var text = block.text;\n\t\n\t  if (text.length > 0) {\n\t    var inlineStyles = getStyleArrayForBlock(block);\n\t    var section = void 0;\n\t    for (var i = start; i < end; i += 1) {\n\t      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n\t        section.text.push(text[i]);\n\t        section.end = i + 1;\n\t      } else {\n\t        section = {\n\t          styles: getStylesAtOffset(inlineStyles, i),\n\t          text: [text[i]],\n\t          start: i,\n\t          end: i + 1\n\t        };\n\t        styleSections.push(section);\n\t      }\n\t    }\n\t  }\n\t  return styleSections;\n\t}\n\t\n\t/**\n\t* Replace leading blank spaces by &nbsp;\n\t*/\n\tfunction trimLeadingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = 0; i < replacedText.length; i += 1) {\n\t      if (sectionText[i] === ' ') {\n\t        replacedText = replacedText.replace(' ', '&nbsp;');\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Replace trailing blank spaces by &nbsp;\n\t*/\n\tfunction trimTrailingZeros(sectionText) {\n\t  if (sectionText) {\n\t    var replacedText = sectionText;\n\t    for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n\t      if (replacedText[i] === ' ') {\n\t        replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\t    return replacedText;\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* The method returns markup for section to which inline styles\n\t* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n\t*/\n\tfunction getStyleTagSectionMarkup(styles, text) {\n\t  var content = text;\n\t  (0, _common.forEach)(styles, function (style, value) {\n\t    content = addInlineStyleMarkup(style, content, value);\n\t  });\n\t  return content;\n\t}\n\t\n\t/**\n\t* The method returns markup for section to which inline styles\n\tlike color, background-color, font-size are applicable.\n\t*/\n\tfunction getInlineStyleSectionMarkup(block, styleSection) {\n\t  var stylePropertySections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], styleSection.start, styleSection.end);\n\t  var styleSectionText = '';\n\t  stylePropertySections.forEach(function (stylePropertySection) {\n\t    styleSectionText += addStylePropertyMarkup(stylePropertySection);\n\t  });\n\t  styleSectionText = getStyleTagSectionMarkup(styleSection.styles, styleSectionText);\n\t  return styleSectionText;\n\t}\n\t\n\t/**\n\t* The method returns markup for an entity section.\n\t* An entity section is a continuous section in a block\n\t* to which same entity or no entity is applicable.\n\t*/\n\tfunction getEntitySectionMarkup(block, entityMap, entitySection) {\n\t  var entitySectionMarkup = [];\n\t  var inlineStyleSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], entitySection.start, entitySection.end);\n\t  inlineStyleSections.forEach(function (styleSection) {\n\t    entitySectionMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n\t  });\n\t  var sectionText = entitySectionMarkup.join('');\n\t  if (entitySection.entityKey !== undefined && entitySection.entityKey !== null) {\n\t    sectionText = getEntityMarkup(entityMap, entitySection.entityKey, sectionText);\n\t  }\n\t  return sectionText;\n\t}\n\t\n\t/**\n\t* Function will return the markup for block preserving the inline styles and\n\t* special characters like newlines or blank spaces.\n\t*/\n\tfunction getBlockInnerMarkup(block, entityMap) {\n\t  var blockMarkup = [];\n\t  var entitySections = getEntitySections(block.entityRanges, block.text.length);\n\t  entitySections.forEach(function (section, index) {\n\t    var sectionText = getEntitySectionMarkup(block, entityMap, section);\n\t    if (index === 0) {\n\t      sectionText = trimLeadingZeros(sectionText);\n\t    }\n\t    if (index === entitySections.length - 1) {\n\t      sectionText = trimTrailingZeros(sectionText);\n\t    }\n\t    blockMarkup.push(sectionText);\n\t  });\n\t  return blockMarkup.join('');\n\t}\n\t\n\t/**\n\t* Function will return html for the block.\n\t*/\n\tfunction getBlockMarkup(block, entityMap, directional) {\n\t  var blockHtml = [];\n\t  if (isAtomicEntityBlock(block)) {\n\t    blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key));\n\t  } else {\n\t    var blockTag = getBlockTag(block.type);\n\t    if (blockTag) {\n\t      blockHtml.push('<' + blockTag);\n\t      var blockStyle = getBlockStyle(block.data);\n\t      if (blockStyle) {\n\t        blockHtml.push(' style=\"' + blockStyle + '\"');\n\t      }\n\t      if (directional) {\n\t        blockHtml.push(' dir = \"auto\"');\n\t      }\n\t      blockHtml.push('>');\n\t      blockHtml.push(getBlockInnerMarkup(block, entityMap));\n\t      blockHtml.push('</' + blockTag + '>');\n\t    }\n\t  }\n\t  blockHtml.push('\\n');\n\t  return blockHtml.join('');\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.forEach = forEach;\n\texports.isEmptyString = isEmptyString;\n\t\n\t\n\t/**\n\t* Utility function to execute callback for eack key->value pair.\n\t*/\n\tfunction forEach(obj, callback) {\n\t  if (obj) {\n\t    for (var key in obj) {\n\t      // eslint-disable-line no-restricted-syntax\n\t      if ({}.hasOwnProperty.call(obj, key)) {\n\t        callback(key, obj[key]);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t* The function returns true if the string passed to it has no content.\n\t*/\n\tfunction isEmptyString(str) {\n\t  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n\t    return true;\n\t  }\n\t  return false;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = draftToHtml;\n\t\n\tvar _block = __webpack_require__(1);\n\t\n\tvar _list = __webpack_require__(4);\n\t\n\t/**\n\t* The funciton will generate html markup for given draftjs editorContent.\n\t*/\n\tfunction draftToHtml(editorContent, directional) {\n\t  var html = [];\n\t  if (editorContent) {\n\t    (function () {\n\t      var blocks = editorContent.blocks,\n\t          entityMap = editorContent.entityMap;\n\t\n\t      if (blocks && blocks.length > 0) {\n\t        (function () {\n\t          var listBlocks = [];\n\t          blocks.forEach(function (block) {\n\t            if ((0, _list.isList)(block.type)) {\n\t              listBlocks.push(block);\n\t            } else {\n\t              if (listBlocks.length > 0) {\n\t                var listHtml = (0, _list.getListMarkup)(listBlocks, entityMap);\n\t                html.push(listHtml);\n\t                listBlocks = [];\n\t              }\n\t              var blockHtml = (0, _block.getBlockMarkup)(block, entityMap, directional);\n\t              html.push(blockHtml);\n\t            }\n\t          });\n\t          if (listBlocks.length > 0) {\n\t            var listHtml = (0, _list.getListMarkup)(listBlocks, entityMap);\n\t            html.push(listHtml);\n\t            listBlocks = [];\n\t          }\n\t        })();\n\t      }\n\t    })();\n\t  }\n\t  return html.join('');\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.isList = isList;\n\texports.getListMarkup = getListMarkup;\n\t\n\tvar _block = __webpack_require__(1);\n\t\n\t/**\n\t* Function to check if a block is of type list.\n\t*/\n\tfunction isList(blockType) {\n\t  return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n\t}\n\t\n\t/**\n\t* Function will return html markup for a list block.\n\t*/\n\tfunction getListMarkup(listBlocks, entityMap) {\n\t  var listHtml = [];\n\t  var nestedListBlock = [];\n\t  var previousBlock = void 0;\n\t  listBlocks.forEach(function (block) {\n\t    var nestedBlock = false;\n\t    if (!previousBlock) {\n\t      listHtml.push('<' + (0, _block.getBlockTag)(block.type) + '>\\n');\n\t    } else if (previousBlock.type !== block.type) {\n\t      listHtml.push('</' + (0, _block.getBlockTag)(previousBlock.type) + '>\\n');\n\t      listHtml.push('<' + (0, _block.getBlockTag)(block.type) + '>\\n');\n\t    } else if (previousBlock.depth === block.depth) {\n\t      if (nestedListBlock && nestedListBlock.length > 0) {\n\t        listHtml.push(getListMarkup(nestedListBlock));\n\t        nestedListBlock = [];\n\t      }\n\t    } else {\n\t      nestedBlock = true;\n\t      nestedListBlock.push(block);\n\t    }\n\t    if (!nestedBlock) {\n\t      listHtml.push('<li');\n\t      var blockStyle = (0, _block.getBlockStyle)(block.data);\n\t      if (blockStyle) {\n\t        listHtml.push(' style=\"' + blockStyle + '\"');\n\t      }\n\t      listHtml.push('>');\n\t      listHtml.push((0, _block.getBlockInnerMarkup)(block, entityMap));\n\t      listHtml.push('</li>\\n');\n\t      previousBlock = block;\n\t    }\n\t  });\n\t  if (nestedListBlock && nestedListBlock.length > 0) {\n\t    listHtml.push(getListMarkup(nestedListBlock));\n\t  }\n\t  listHtml.push('</' + (0, _block.getBlockTag)(previousBlock.type) + '>\\n');\n\t  return listHtml.join('');\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// draftjs-to-html.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap db8e10e748f77b20def0","import {\n  forEach,\n  isEmptyString,\n} from './common';\n\n/**\n* Mapping block-type to corresponding html tag.\n*/\nconst blockTypesMapping: Object = {\n  unstyled: 'p',\n  'header-one': 'h1',\n  'header-two': 'h2',\n  'header-three': 'h3',\n  'header-four': 'h4',\n  'header-five': 'h5',\n  'header-six': 'h6',\n  'unordered-list-item': 'ul',\n  'ordered-list-item': 'ol',\n  blockquote: 'blockquote',\n};\n\n/**\n* Function will return HTML tag for a block.\n*/\nexport function getBlockTag(type: string): string {\n  return type && blockTypesMapping[type];\n}\n\n/**\n* Function will return style string for a block.\n*/\nexport function getBlockStyle(data: Object): string {\n  let styles = '';\n  forEach(data, (key, value) => {\n    if (value) {\n      styles += `${key}:${value};`;\n    }\n  });\n  return styles;\n}\n\n/**\n* The function returns an array of entity-sections in blocks.\n* These will be areas in block which have same entity or no entity applicable to them.\n*/\nfunction getEntitySections(entityRanges: Object, blockLength: number): Array<Object> {\n  const sections = [];\n  let lastOffset = 0;\n  entityRanges.forEach((r) => {\n    if (r.offset > lastOffset) {\n      sections.push({\n        start: lastOffset,\n        end: r.offset,\n      });\n    }\n    sections.push({\n      start: r.offset,\n      end: r.offset + r.length,\n      entityKey: r.key,\n    });\n    lastOffset = r.offset + r.length;\n  });\n  if (lastOffset < blockLength) {\n    sections.push({\n      start: lastOffset,\n      end: blockLength,\n    });\n  }\n  return sections;\n}\n\n/**\n* Function to check if the block is an atomic entity block.\n*/\nfunction isAtomicEntityBlock(block: Object): boolean {\n  if (block.entityRanges.length > 0 && isEmptyString(block.text)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* The function will return array of inline styles applicable to the block.\n*/\nfunction getStyleArrayForBlock(block: Object): Object {\n  const { text, inlineStyleRanges } = block;\n  const inlineStyles = {\n    BOLD: new Array(text.length),\n    ITALIC: new Array(text.length),\n    UNDERLINE: new Array(text.length),\n    STRIKETHROUGH: new Array(text.length),\n    CODE: new Array(text.length),\n    SUPERSCRIPT: new Array(text.length),\n    SUBSCRIPT: new Array(text.length),\n    COLOR: new Array(text.length),\n    BGCOLOR: new Array(text.length),\n    FONTSIZE: new Array(text.length),\n    FONTFAMILY: new Array(text.length),\n    length: text.length,\n  };\n  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n    inlineStyleRanges.forEach((range) => {\n      const offset = range.offset;\n      const length = offset + range.length;\n      for (let i = offset; i < length; i += 1) {\n        if (range.style.startsWith('color-')) {\n          inlineStyles.COLOR[i] = range.style.substring(6);\n        } else if (range.style.startsWith('bgcolor-')) {\n          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n        } else if (range.style.startsWith('fontsize-')) {\n          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n        } else if (range.style.startsWith('fontfamily-')) {\n          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n        } else if (inlineStyles[range.style]) {\n          inlineStyles[range.style][i] = true;\n        }\n      }\n    });\n  }\n  return inlineStyles;\n}\n\n/**\n* The function will return inline style applicable at some offset within a block.\n*/\nexport function getStylesAtOffset(inlineStyles: Object, offset: number): Object {\n  const styles = {};\n  if (inlineStyles.COLOR[offset]) {\n    styles.COLOR = inlineStyles.COLOR[offset];\n  }\n  if (inlineStyles.BGCOLOR[offset]) {\n    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n  }\n  if (inlineStyles.FONTSIZE[offset]) {\n    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n  }\n  if (inlineStyles.FONTFAMILY[offset]) {\n    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n  }\n  if (inlineStyles.UNDERLINE[offset]) {\n    styles.UNDERLINE = true;\n  }\n  if (inlineStyles.ITALIC[offset]) {\n    styles.ITALIC = true;\n  }\n  if (inlineStyles.BOLD[offset]) {\n    styles.BOLD = true;\n  }\n  if (inlineStyles.STRIKETHROUGH[offset]) {\n    styles.STRIKETHROUGH = true;\n  }\n  if (inlineStyles.CODE[offset]) {\n    styles.CODE = true;\n  }\n  if (inlineStyles.SUBSCRIPT[offset]) {\n    styles.SUBSCRIPT = true;\n  }\n  if (inlineStyles.SUPERSCRIPT[offset]) {\n    styles.SUPERSCRIPT = true;\n  }\n  return styles;\n}\n\n/**\n* Function returns true for a set of styles if the value of these styles at an offset\n* are same as that on the previous offset.\n*/\nexport function sameStyleAsPrevious(\n  inlineStyles: Object,\n  styles: Array<string>,\n  index: number,\n): boolean {\n  let sameStyled = true;\n  if (index > 0 && index < inlineStyles.length) {\n    styles.forEach((style) => {\n      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n    });\n  } else {\n    sameStyled = false;\n  }\n  return sameStyled;\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nexport function addInlineStyleMarkup(style: string, content: string): string {\n  if (style === 'BOLD') {\n    return `<strong>${content}</strong>`;\n  } else if (style === 'ITALIC') {\n    return `<em>${content}</em>`;\n  } else if (style === 'UNDERLINE') {\n    return `<ins>${content}</ins>`;\n  } else if (style === 'STRIKETHROUGH') {\n    return `<del>${content}</del>`;\n  } else if (style === 'CODE') {\n    return `<code>${content}</code>`;\n  } else if (style === 'SUPERSCRIPT') {\n    return `<sup>${content}</sup>`;\n  } else if (style === 'SUBSCRIPT') {\n    return `<sub>${content}</sub>`;\n  }\n  return content;\n}\n\n/**\n* The function returns text for given section of block after doing required character replacements.\n*/\nfunction getSectionText(text: Array<string>): string {\n  if (text && text.length > 0) {\n    const chars = text.map((ch) => {\n      switch (ch) {\n        case '\\n':\n          return '<br>\\n';\n        case '&':\n          return '&amp;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        default:\n          return ch;\n      }\n    });\n    return chars.join('');\n  }\n  return '';\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nexport function addStylePropertyMarkup(styleSection: Object): string {\n  const { styles, text } = styleSection;\n  const content = getSectionText(text);\n  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n    let styleString = 'style=\"';\n    if (styles.COLOR) {\n      styleString += `color: ${styles.COLOR};`;\n    }\n    if (styles.BGCOLOR) {\n      styleString += `background-color: ${styles.BGCOLOR};`;\n    }\n    if (styles.FONTSIZE) {\n      styleString += `font-size: ${styles.FONTSIZE}px;`;\n    }\n    if (styles.FONTFAMILY) {\n      styleString += `font-family: ${styles.FONTFAMILY};`;\n    }\n    styleString += '\"';\n    return `<span ${styleString}>${content}</span>`;\n  }\n  return content;\n}\n\n/**\n* Function will return markup for Entity.\n*/\nfunction getEntityMarkup(entityMap: Object, entityKey: number, text: string): string {\n  const entity = entityMap[entityKey];\n  if (entity.type === 'MENTION') {\n    return `<a href=\"${entity.data.url}\" class=\"wysiwyg-mention\" data-mention data-value=\"${entity.data.value}\">${text}</a>`;\n  }\n  if (entity.type === 'LINK') {\n    return `<a href=\"${entity.data.url}\">${entity.data.title}</a>`;\n  }\n  if (entity.type === 'IMAGE') {\n    return `<img src=\"${entity.data.src}\" style=\"float:${entity.data.alignment || 'none'};height: ${entity.data.height};width: ${entity.data.width}\"/>`;\n  }\n  if (entity.type === 'EMBEDDED_LINK') {\n    return `<iframe width=\"${entity.data.width}\" height=\"${entity.data.height}\" src=\"${entity.data.src}\" frameBorder=\"0\" allowFullScreen />`;\n  }\n  return text;\n}\n\n/**\n* For a given section in a block the function will return a further list of sections,\n* with similar inline styles applicable to them.\n*/\nfunction getInlineStyleSections(\n  block: Object,\n  styles: Array<string>,\n  start: number,\n  end: number,\n): Array<Object> {\n  const styleSections = [];\n  const { text } = block;\n  if (text.length > 0) {\n    const inlineStyles = getStyleArrayForBlock(block);\n    let section;\n    for (let i = start; i < end; i += 1) {\n      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n        section.text.push(text[i]);\n        section.end = i + 1;\n      } else {\n        section = {\n          styles: getStylesAtOffset(inlineStyles, i),\n          text: [text[i]],\n          start: i,\n          end: i + 1,\n        };\n        styleSections.push(section);\n      }\n    }\n  }\n  return styleSections;\n}\n\n/**\n* Replace leading blank spaces by &nbsp;\n*/\nexport function trimLeadingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = 0; i < replacedText.length; i += 1) {\n      if (sectionText[i] === ' ') {\n        replacedText = replacedText.replace(' ', '&nbsp;');\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Replace trailing blank spaces by &nbsp;\n*/\nexport function trimTrailingZeros(sectionText: string): string {\n  if (sectionText) {\n    let replacedText = sectionText;\n    for (let i = replacedText.length - 1; i >= 0; i -= 1) {\n      if (replacedText[i] === ' ') {\n        replacedText = `${replacedText.substring(0, i)}&nbsp;${replacedText.substring(i + 1)}`;\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* The method returns markup for section to which inline styles\n* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n*/\nfunction getStyleTagSectionMarkup(styles: Object, text: string): string {\n  let content = text;\n  forEach(styles, (style, value) => {\n    content = addInlineStyleMarkup(style, content, value);\n  });\n  return content;\n}\n\n\n/**\n* The method returns markup for section to which inline styles\nlike color, background-color, font-size are applicable.\n*/\nfunction getInlineStyleSectionMarkup(block: Object, styleSection: Object): string {\n  const stylePropertySections = getInlineStyleSections(\n    block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], styleSection.start, styleSection.end,\n  );\n  let styleSectionText = '';\n  stylePropertySections.forEach((stylePropertySection) => {\n    styleSectionText += addStylePropertyMarkup(stylePropertySection);\n  });\n  styleSectionText =\n    getStyleTagSectionMarkup(styleSection.styles, styleSectionText);\n  return styleSectionText;\n}\n\n/**\n* The method returns markup for an entity section.\n* An entity section is a continuous section in a block\n* to which same entity or no entity is applicable.\n*/\nfunction getEntitySectionMarkup(block: Object, entityMap: Object, entitySection: Object): string {\n  const entitySectionMarkup = [];\n  const inlineStyleSections = getInlineStyleSections(\n    block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], entitySection.start, entitySection.end,\n  );\n  inlineStyleSections.forEach((styleSection) => {\n    entitySectionMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n  });\n  let sectionText = entitySectionMarkup.join('');\n  if (entitySection.entityKey !== undefined && entitySection.entityKey !== null) {\n    sectionText = getEntityMarkup(entityMap, entitySection.entityKey, sectionText);\n  }\n  return sectionText;\n}\n\n/**\n* Function will return the markup for block preserving the inline styles and\n* special characters like newlines or blank spaces.\n*/\nexport function getBlockInnerMarkup(block: Object, entityMap: Object): string {\n  const blockMarkup = [];\n  const entitySections = getEntitySections(block.entityRanges, block.text.length);\n  entitySections.forEach((section, index) => {\n    let sectionText = getEntitySectionMarkup(block, entityMap, section);\n    if (index === 0) {\n      sectionText = trimLeadingZeros(sectionText);\n    }\n    if (index === entitySections.length - 1) {\n      sectionText = trimTrailingZeros(sectionText);\n    }\n    blockMarkup.push(sectionText);\n  });\n  return blockMarkup.join('');\n}\n\n/**\n* Function will return html for the block.\n*/\nexport function getBlockMarkup(block: Object, entityMap: Object, directional: boolean): string {\n  const blockHtml = [];\n  if (isAtomicEntityBlock(block)) {\n    blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key));\n  } else {\n    const blockTag = getBlockTag(block.type);\n    if (blockTag) {\n      blockHtml.push(`<${blockTag}`);\n      const blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        blockHtml.push(` style=\"${blockStyle}\"`);\n      }\n      if (directional) {\n        blockHtml.push(' dir = \"auto\"');\n      }\n      blockHtml.push('>');\n      blockHtml.push(getBlockInnerMarkup(block, entityMap));\n      blockHtml.push(`</${blockTag}>`);\n    }\n  }\n  blockHtml.push('\\n');\n  return blockHtml.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/block.js","/* @flow */\n\n/**\n* Utility function to execute callback for eack key->value pair.\n*/\nexport function forEach(obj: Object, callback: Function) {\n  if (obj) {\n    for (const key in obj) { // eslint-disable-line no-restricted-syntax\n      if ({}.hasOwnProperty.call(obj, key)) {\n        callback(key, obj[key]);\n      }\n    }\n  }\n}\n\n/**\n* The function returns true if the string passed to it has no content.\n*/\nexport function isEmptyString(str: string): boolean {\n  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n    return true;\n  }\n  return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/common.js","/* @flow */\n\nimport { getBlockMarkup } from './block';\nimport { isList, getListMarkup } from './list';\n\n/**\n* The funciton will generate html markup for given draftjs editorContent.\n*/\nexport default function draftToHtml(editorContent: Object, directional: boolean): string {\n  const html = [];\n  if (editorContent) {\n    const { blocks, entityMap } = editorContent;\n    if (blocks && blocks.length > 0) {\n      let listBlocks = [];\n      blocks.forEach((block) => {\n        if (isList(block.type)) {\n          listBlocks.push(block);\n        } else {\n          if (listBlocks.length > 0) {\n            const listHtml = getListMarkup(listBlocks, entityMap);\n            html.push(listHtml);\n            listBlocks = [];\n          }\n          const blockHtml = getBlockMarkup(block, entityMap, directional);\n          html.push(blockHtml);\n        }\n      });\n      if (listBlocks.length > 0) {\n        const listHtml = getListMarkup(listBlocks, entityMap);\n        html.push(listHtml);\n        listBlocks = [];\n      }\n    }\n  }\n  return html.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/index.js","import {\n  getBlockTag,\n  getBlockStyle,\n  getBlockInnerMarkup,\n} from './block';\n\n/**\n* Function to check if a block is of type list.\n*/\nexport function isList(blockType: string): any {\n  return (\n    blockType === 'unordered-list-item' ||\n    blockType === 'ordered-list-item'\n  );\n}\n\n/**\n* Function will return html markup for a list block.\n*/\nexport function getListMarkup(listBlocks: Array<Object>, entityMap: Object): string {\n  const listHtml = [];\n  let nestedListBlock = [];\n  let previousBlock;\n  listBlocks.forEach((block) => {\n    let nestedBlock = false;\n    if (!previousBlock) {\n      listHtml.push(`<${getBlockTag(block.type)}>\\n`);\n    } else if (previousBlock.type !== block.type) {\n      listHtml.push(`</${getBlockTag(previousBlock.type)}>\\n`);\n      listHtml.push(`<${getBlockTag(block.type)}>\\n`);\n    } else if (previousBlock.depth === block.depth) {\n      if (nestedListBlock && nestedListBlock.length > 0) {\n        listHtml.push(getListMarkup(nestedListBlock));\n        nestedListBlock = [];\n      }\n    } else {\n      nestedBlock = true;\n      nestedListBlock.push(block);\n    }\n    if (!nestedBlock) {\n      listHtml.push('<li');\n      const blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        listHtml.push(` style=\"${blockStyle}\"`);\n      }\n      listHtml.push('>');\n      listHtml.push(getBlockInnerMarkup(block, entityMap));\n      listHtml.push('</li>\\n');\n      previousBlock = block;\n    }\n  });\n  if (nestedListBlock && nestedListBlock.length > 0) {\n    listHtml.push(getListMarkup(nestedListBlock));\n  }\n  listHtml.push(`</${getBlockTag(previousBlock.type)}>\\n`);\n  return listHtml.join('');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/list.js"],"sourceRoot":""}